<html>

	<head>
	
		<title> Limbajul C++ </title>
		<link href="style.css" type="text/css" rel="stylesheet">
		
	</head>
	
	<body>
	
		<div id="antet">
			PROIECT HTML / CSS / JAVA SCRIPT
		</div>
		
		<div id="meniu">
			<table><tr>
				<td><img src="cpp_programming.png" height="41px"/></td>
				<td><ul>

						<li><a href="../Proiect.html"><table><th>
								<td><pre> </pre></td>
								<td><font size="5px">Acasa</font></td>
								<td><pre> <img src="menu-avatar.png" height="31px"/></pre></td>
								</th></table>
						</a></li>
						
						<li><a> Lectii</a>
	
							<ul>
		
								<li><a> Tutoriale C++</a>
									<ul>
									
										<li><a href="Structura unui program C++.html"> Structura unui program C++</a></li>
										<li><a href="Identificatori - Variabile - Atribuire.html"> Identificatori - Variabile - Atribuire</a></li>
										<li><a href="Constante - Operatori Aritmetici - Atribuire compusă.html"> Constante - Operatori Aritmetici - Atribuire compusă</a></li>
										<li><a href="Input Output cu CIN şi COUT.html"> Input / Output cu CIN şi COUT</a></li>
										<li><a href="Booleeni şi Structuri de Control.html"> Booleeni şi Structuri de Control</a></li>
										<li><a href="Vectori - Tablouri de memorie.html"> Vectori - Tablouri de memorie</a></li>
										<li><a href="Funcţii (Subprograme).html"> Funcţii (Subprograme)</a></li>
										<li><a href="Pointeri, Memorie Dinamică, Referinţe.html"> Pointeri, Memorie Dinamică, Referinţe</a></li>
									
									</ul>
								</li>
								<li><a> Algoritmi</a>
									<ul>
									
										<li><a href="Primalitatea unui număr.html"> Primalitatea unui număr</a></li>
										<li><a href="Generarea Numerelor Prime.html"> Generarea Numerelor Prime</a></li>
										<li><a href="Algoritmul lui Euclid (CMMDC).html"> Algoritmul lui Euclid (CMMDC)</a></li>
										<li><a href="Căutarea Binară.html"> Căutarea Binară</a></li>
										<li><a href="Metoda bisecţiei.html"> Metoda bisecţiei</a></li>
									
									</ul>
								</li>
								<li><a> Structuri de date</a>
									<ul>
									
										<li><a href="Lista Liniară Simplu Înlănţuită.html"> Lista Liniară Simplu Înlănţuită</a></li>
										<li><a href="Lista Liniară Dublu Înlănţuită.html"> Lista Liniară Dublu Înlănţuită</a></li>
										<li><a href="Lista Circulară Simplu Înlanţuită.html"> Lista Circulară Simplu Înlanţuită</a></li>
										<li><a href="Stiva (Stack).html"> Stiva (Stack)</a></li>
										<li><a href="Coada (Queue).html"> Coada (Queue)</a></li>
									
									</ul>
								</li>
			
							</ul>
	
						</li>
	
						<li><a> Probleme</a>
	
							<ul>
		
								<li><a href="Tinta.html"> Tinta</a></li>
								<li><a href="Problema_2.html"> Problema_2</a></li>
								<li><a href="Problema_3.html"> Problema_3</a></li>
								<li><a href="Problema_4.html"> Problema_4</a></li>
								<li><a href="Problema_5.html"> Problema_5</a></li>
								<li><a href="Problema_6.html"> Problema_6</a></li>
								<li><a href="Problema_7.html"> Problema_7</a></li>
		
							</ul>
	
						</li>
	
						<li><a href="Test.html"> Test</a></li>

					</ul></td></tr></table>
		</div>
		
		<div id="continut">
			<div id="titlu_lectie">
				Generarea Numerelor Prime
			</div>
			<div id="lectie">
				
				<div id="subtitlu">
					Metoda Clasică
				</div>
				
				Metoda clasică de generare a numerelor prime până la o anumită limită presupune iterarea până la acea limită şi verificarea primalităţii fiecărui număr. Dacă este prim atunci va fi afişat pe ecran. Algoritmul în C++:
				
				<div id="cod">
				<pre>
bool IsPrime(int n)
{
    for(int i = 2; i <= sqrt(n); i++)
        // Daca i divide n, atunci n nu este prim
        if(n % i == 0) return false;
    // Daca am ajuns aici inseamna ca n este prim
    return true;
}

void MetodaClasica(int lim)
{
    cout << 2 << ' ' << 3 << ' ';
    for(int i = 5; i <= lim; i+=2)
        if(IsPrime(i)) cout << i << ' ';
    cout << '\n';
}
				</pre>
				</div>
				
				Observaţi că sar peste numerele pare (i+=2) deoarece singurul număr par prim este 2. Acest algoritm generează toate numerele prime până la lim. Totuşi există metode mai bune de generare a numerelor prime, iar una din ele este Ciurul lui Eratostene.
				
				<div id="subtitlu">
					Ciurul lui Eratostene
				</div>
				
				Ciurul lui Eratostene (Sieve of Eratosthenes) este un algoritm de găsire a tuturor numerelor prime până la un număr dat. De data aceasta voi număra numerele prime. Paşii algoritmului:
				
				<ol>
					
					<li>Se iterează de la 2 până la sqrt(lim).</li>
					<li>Fie p, primul număr prim găsit.</li>
					<li>Toţi multiplii numărului p*p se marchează ca fiind compuşi (adică ne-primi).</li>
					<li>În final se numără sau se afişează toate numerele prime din intervalul [sqrt(lim)+1, lim].</li>
					
				</ol>
				
				Algoritmul în C++:
				
				<div id="cod">
				<pre>
void Eratostene(int lim) 
{
    int sqr = (int)sqrt(lim); 
    // Variabila in care numar numerele prime
    int nr = 0; 
    // Marcarea numerelor prime se face in acest vector
    bool * isComposite = new bool[lim+1]; 
    // Initial toate sunt prime
    memset(isComposite, 0, sizeof(bool)*(lim+1));
    for(int p = 2; p <= sqr; p++)
    {
        // Daca nu este compus, adica este prim
        if(!isComposite[p])
        {
            ++nr;
            // Marcheaza toti multiplii p*p ca fiind compusi
            for(int k = p*p; k <= lim; k+=p)
            isComposite[k] = true;
        }
    }
    // Numara numerele prime ramase
    for(int i = sqr+1; i <= lim; i++)
        if(!isComposite[i]) ++nr;
    cout << nr << '\n';
    delete[] isComposite;
}
				</pre>
				</div>
				
				<div id="subtitlu">
					Ciurul lui Atkin
				</div>
				
				Ciurul lui Atkin (Sieve of Atkin) este un algoritm rapid şi modern de găsire a tuturor numerelor prime până la un număr întreg. A fost creat de A.O.L. Atkin şi Daniel J. Bernstein. Vă ofer doar implementarea algoritmului în C++, nu şi explicaţia:
				
				<div id="cod">
				<pre>
void Atkin(int lim)
{
    double sqr = sqrt(lim); int n, nr = 2;
    bool * isPrime = new bool[lim+1];
    // Initial toate numerele sunt neprime
    memset(isPrime, 0, sizeof(bool)*(lim+1));
    for(int x = 1; x <= sqr; x++)
    {
        for(int y = 1; y <= sqr; y++)
        {
            n = 4 * x * x + y * y;
            if(n <= lim && (n % 12 == 1 || n % 12 == 5))
                isPrime[n] = !isPrime[n];
            n = 3 * x * x + y * y;
            if(n <= lim && n % 12 == 7)
                isPrime[n] = !isPrime[n];
            n = 3 * x * x - y * y;
            if(x > y && n <= lim && n % 12 == 11)
                isPrime[n] = !isPrime[n];
        }
    }
    for(int i = 5; i <= sqr; i+=2) 
    {
        // Daca este prim, marcheaza toti multiplii i*i ca fiind neprimi
        if(isPrime[i])
        {
            for(int k = i*i; k <= lim; k+=i*i)
            isPrime[k] = false;
        }
    }
    // Numara numerele prime
    for(int i = 5; i <= lim; i+=2)
        if(isPrime[i]) ++nr;
    cout << nr << '\n';
    delete[] isPrime;
}
				</pre>
				</div>
				
			</div>	
			<div id="button">
				<a href="#"><img src="sageata sus.png" height="50px" width="50px"/></a>
			</div>
		</div>
		
		<div id="subsol">
			Realizat de Alex si Cristi
		</div>
	
	</body>
	
</html>